/*******************************************************************************
 * Pattern signature of the kevoree.enforcedRule pattern
 * Generated by EMF-IncQuery
 *******************************************************************************/

package signatures.kevoree;

import java.util.Arrays;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.viatra2.emf.incquery.runtime.api.IPatternSignature;
import org.eclipse.viatra2.emf.incquery.runtime.api.impl.BasePatternSignature;

/**
 * Pattern-specific signature object of the kevoree.enforcedRule pattern.
 * Class fields correspond to parameters of the pattern. Fields with value null are considered unassigned.
 * Each instance is a (possibly partial) substitution of pattern parameters, 
 * usable e.g. to represent a match of the pattern in the result of a query, 
 * or to specify the bound (fixed) input parameters when issuing a query.
 */
@SuppressWarnings("unused")
public final class EnforcedRuleSignature extends BasePatternSignature implements IPatternSignature {

	// constructor
	public EnforcedRuleSignature(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		this.fN1 = N1;
		this.fCOMP1 = COMP1;
		this.fPORT1 = PORT1;
		this.fBIND1 = BIND1;
		this.fCHAN = CHAN;
		this.fN2 = N2;
		this.fCOMP2 = COMP2;
		this.fPORT2 = PORT2;
		this.fBIND2 = BIND2;	
	}

	//private attributes
	private Object fN1;
	private Object fCOMP1;
	private Object fPORT1;
	private Object fBIND1;
	private Object fCHAN;
	private Object fN2;
	private Object fCOMP2;
	private Object fPORT2;
	private Object fBIND2;
	
	// getter methods
	/** Returns the value of the parameter with the given name, or null if name is invalid. */
	@Override
	public Object get(String parameterName) {
		if ("N1".equals(parameterName)) return fN1;
		if ("COMP1".equals(parameterName)) return fCOMP1;
		if ("PORT1".equals(parameterName)) return fPORT1;
		if ("BIND1".equals(parameterName)) return fBIND1;
		if ("CHAN".equals(parameterName)) return fCHAN;
		if ("N2".equals(parameterName)) return fN2;
		if ("COMP2".equals(parameterName)) return fCOMP2;
		if ("PORT2".equals(parameterName)) return fPORT2;
		if ("BIND2".equals(parameterName)) return fBIND2;
		return null;
	}	
	
	public Object getValueOfN1(){
		 return fN1;
	}
	public Object getValueOfCOMP1(){
		 return fCOMP1;
	}
	public Object getValueOfPORT1(){
		 return fPORT1;
	}
	public Object getValueOfBIND1(){
		 return fBIND1;
	}
	public Object getValueOfCHAN(){
		 return fCHAN;
	}
	public Object getValueOfN2(){
		 return fN2;
	}
	public Object getValueOfCOMP2(){
		 return fCOMP2;
	}
	public Object getValueOfPORT2(){
		 return fPORT2;
	}
	public Object getValueOfBIND2(){
		 return fBIND2;
	}	
	
	// setter methods
	/** 
	 * Sets the parameter with the given name to the given value. 
	 * @returns true if successful, false if parameter name is invalid. May also fail and return false if the value type is incompatible. 
	 */
	@Override
	public boolean set(String parameterName, Object newValue) {
		if ("N1".equals(parameterName)) {
			fN1 = newValue;
			return true;
		}
		if ("COMP1".equals(parameterName)) {
			fCOMP1 = newValue;
			return true;
		}
		if ("PORT1".equals(parameterName)) {
			fPORT1 = newValue;
			return true;
		}
		if ("BIND1".equals(parameterName)) {
			fBIND1 = newValue;
			return true;
		}
		if ("CHAN".equals(parameterName)) {
			fCHAN = newValue;
			return true;
		}
		if ("N2".equals(parameterName)) {
			fN2 = newValue;
			return true;
		}
		if ("COMP2".equals(parameterName)) {
			fCOMP2 = newValue;
			return true;
		}
		if ("PORT2".equals(parameterName)) {
			fPORT2 = newValue;
			return true;
		}
		if ("BIND2".equals(parameterName)) {
			fBIND2 = newValue;
			return true;
		}
		return false;
	}
	
	public void setValueOfN1(Object N1){
		 this.fN1=N1;
	}
	public void setValueOfCOMP1(Object COMP1){
		 this.fCOMP1=COMP1;
	}
	public void setValueOfPORT1(Object PORT1){
		 this.fPORT1=PORT1;
	}
	public void setValueOfBIND1(Object BIND1){
		 this.fBIND1=BIND1;
	}
	public void setValueOfCHAN(Object CHAN){
		 this.fCHAN=CHAN;
	}
	public void setValueOfN2(Object N2){
		 this.fN2=N2;
	}
	public void setValueOfCOMP2(Object COMP2){
		 this.fCOMP2=COMP2;
	}
	public void setValueOfPORT2(Object PORT2){
		 this.fPORT2=PORT2;
	}
	public void setValueOfBIND2(Object BIND2){
		 this.fBIND2=BIND2;
	}

	// overridden prettyPrint(), hashCode(), equals() with Tuple-semantics
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (! (obj instanceof IPatternSignature))
			return false;
		IPatternSignature otherSig = (IPatternSignature) obj;
		if (!patternName().equals(otherSig.patternName()))
			return false;
		if (!EnforcedRuleSignature.class.equals(obj.getClass()))
			return Arrays.deepEquals(toArray(), otherSig.toArray());
		EnforcedRuleSignature other = (EnforcedRuleSignature) obj;
		if (fN1 == null) {if (other.fN1 != null) return false;}
		else if (!fN1.equals(other.fN1)) return false;
		if (fCOMP1 == null) {if (other.fCOMP1 != null) return false;}
		else if (!fCOMP1.equals(other.fCOMP1)) return false;
		if (fPORT1 == null) {if (other.fPORT1 != null) return false;}
		else if (!fPORT1.equals(other.fPORT1)) return false;
		if (fBIND1 == null) {if (other.fBIND1 != null) return false;}
		else if (!fBIND1.equals(other.fBIND1)) return false;
		if (fCHAN == null) {if (other.fCHAN != null) return false;}
		else if (!fCHAN.equals(other.fCHAN)) return false;
		if (fN2 == null) {if (other.fN2 != null) return false;}
		else if (!fN2.equals(other.fN2)) return false;
		if (fCOMP2 == null) {if (other.fCOMP2 != null) return false;}
		else if (!fCOMP2.equals(other.fCOMP2)) return false;
		if (fPORT2 == null) {if (other.fPORT2 != null) return false;}
		else if (!fPORT2.equals(other.fPORT2)) return false;
		if (fBIND2 == null) {if (other.fBIND2 != null) return false;}
		else if (!fBIND2.equals(other.fBIND2)) return false;
		return true;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((fN1 == null) ? 0 : fN1.hashCode());
		result = prime * result + ((fCOMP1 == null) ? 0 : fCOMP1.hashCode());
		result = prime * result + ((fPORT1 == null) ? 0 : fPORT1.hashCode());
		result = prime * result + ((fBIND1 == null) ? 0 : fBIND1.hashCode());
		result = prime * result + ((fCHAN == null) ? 0 : fCHAN.hashCode());
		result = prime * result + ((fN2 == null) ? 0 : fN2.hashCode());
		result = prime * result + ((fCOMP2 == null) ? 0 : fCOMP2.hashCode());
		result = prime * result + ((fPORT2 == null) ? 0 : fPORT2.hashCode());
		result = prime * result + ((fBIND2 == null) ? 0 : fBIND2.hashCode());
		return result;
	}

	@Override
	public String prettyPrint() {
		StringBuilder result = new StringBuilder();
		result.append("\"N1\"=" + prettyPrintValue(fN1));
		result.append(", \"COMP1\"=" + prettyPrintValue(fCOMP1));
		result.append(", \"PORT1\"=" + prettyPrintValue(fPORT1));
		result.append(", \"BIND1\"=" + prettyPrintValue(fBIND1));
		result.append(", \"CHAN\"=" + prettyPrintValue(fCHAN));
		result.append(", \"N2\"=" + prettyPrintValue(fN2));
		result.append(", \"COMP2\"=" + prettyPrintValue(fCOMP2));
		result.append(", \"PORT2\"=" + prettyPrintValue(fPORT2));
		result.append(", \"BIND2\"=" + prettyPrintValue(fBIND2));
		return result.toString();
	}

	// conversion and reflection
	/** Converts the signature to an array representation, with each pattern parameter at their respective position */
	@Override
	public Object[] toArray() {
		return new Object[] {fN1, fCOMP1, fPORT1, fBIND1, fCHAN, fN2, fCOMP2, fPORT2, fBIND2};
	}
	
	/** Identifies the name of the pattern for which this is a signature. */
	@Override
	public String patternName() {
		return "kevoree.enforcedRule";
	}
	
	/** Returns the list of symbolic parameter names. */
	@Override
	public String[] parameterNames() {
		return parameterNames;
	}
	private static String[] parameterNames = {"N1", "COMP1", "PORT1", "BIND1", "CHAN", "N2", "COMP2", "PORT2", "BIND2"};
	
	
}

/*******************************************************************************
 * EMF Specific API of the kevoree.enforcedRule pattern
 * Generated by EMF-IncQuery
 *******************************************************************************/

package patternmatchers.kevoree;

import java.util.Collection;

import org.eclipse.viatra2.emf.incquery.runtime.api.impl.BaseGeneratedMatcher;
import org.eclipse.viatra2.emf.incquery.runtime.api.impl.BaseMatcherFactory;
import org.eclipse.viatra2.emf.incquery.runtime.api.IPatternSignature;
import org.eclipse.viatra2.emf.incquery.runtime.api.IMatcherFactory;
import org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryMatcher;
import org.eclipse.viatra2.emf.incquery.runtime.exception.IncQueryRuntimeException;
import org.eclipse.viatra2.gtasm.patternmatcher.incremental.rete.matcher.ReteEngine;
import org.eclipse.viatra2.gtasm.patternmatcher.incremental.rete.tuple.Tuple;

import signatures.kevoree.EnforcedRuleSignature;

/**
 * Generated domain-specific pattern matcher API of of the kevoree.enforcedRule pattern.
 * Please instantiate using the static field FACTORY.
 */
@SuppressWarnings("unused")
public class EnforcedRuleMatcher extends BaseGeneratedMatcher<EnforcedRuleSignature> implements IncQueryMatcher<EnforcedRuleSignature>{

	public final static IMatcherFactory<EnforcedRuleSignature,EnforcedRuleMatcher> FACTORY = new Factory();
	public static class Factory extends BaseMatcherFactory<EnforcedRuleSignature,EnforcedRuleMatcher> {
			@Override
			public EnforcedRuleMatcher instantiate(ReteEngine<String> reteEngine) throws IncQueryRuntimeException {
				return new EnforcedRuleMatcher(reteEngine);
			}
			@Override
			public String getPatternName() {
				return "kevoree.enforcedRule";
			}
		} 
			
	
	/** 
	 * Returns the set of all pattern matches given some fixed parameters.
	 * @param N1 the fixed value of pattern parameter N1, or null if not bound.
	 * @param COMP1 the fixed value of pattern parameter COMP1, or null if not bound.
	 * @param PORT1 the fixed value of pattern parameter PORT1, or null if not bound.
	 * @param BIND1 the fixed value of pattern parameter BIND1, or null if not bound.
	 * @param CHAN the fixed value of pattern parameter CHAN, or null if not bound.
	 * @param N2 the fixed value of pattern parameter N2, or null if not bound.
	 * @param COMP2 the fixed value of pattern parameter COMP2, or null if not bound.
	 * @param PORT2 the fixed value of pattern parameter PORT2, or null if not bound.
	 * @param BIND2 the fixed value of pattern parameter BIND2, or null if not bound.
	 * @return matches represented as an array containing the values of each parameter.
	 */
	public Collection<Object[]> getAllMatchesAsArray(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		return getAllMatchesAsArray(new Object[] {N1, COMP1, PORT1, BIND1, CHAN, N2, COMP2, PORT2, BIND2});
	}
	
	/** 
	 * Returns the set of all pattern matches given some fixed parameters.
	 * @param N1 the fixed value of pattern parameter N1, or null if not bound.
	 * @param COMP1 the fixed value of pattern parameter COMP1, or null if not bound.
	 * @param PORT1 the fixed value of pattern parameter PORT1, or null if not bound.
	 * @param BIND1 the fixed value of pattern parameter BIND1, or null if not bound.
	 * @param CHAN the fixed value of pattern parameter CHAN, or null if not bound.
	 * @param N2 the fixed value of pattern parameter N2, or null if not bound.
	 * @param COMP2 the fixed value of pattern parameter COMP2, or null if not bound.
	 * @param PORT2 the fixed value of pattern parameter PORT2, or null if not bound.
	 * @param BIND2 the fixed value of pattern parameter BIND2, or null if not bound.
	 * @return matches represented as a EnforcedRuleSignature object.
	 */
	public Collection<EnforcedRuleSignature> getAllMatchesAsSignature(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		return getAllMatchesAsSignature(new Object[] {N1, COMP1, PORT1, BIND1, CHAN, N2, COMP2, PORT2, BIND2});
	}

	/** 
	 * Returns an arbitrary pattern match given some fixed parameters.
	 * Neither determinism nor randomness of selection is guaranteed.
	 * @param N1 the fixed value of pattern parameter N1, or null if not bound.
	 * @param COMP1 the fixed value of pattern parameter COMP1, or null if not bound.
	 * @param PORT1 the fixed value of pattern parameter PORT1, or null if not bound.
	 * @param BIND1 the fixed value of pattern parameter BIND1, or null if not bound.
	 * @param CHAN the fixed value of pattern parameter CHAN, or null if not bound.
	 * @param N2 the fixed value of pattern parameter N2, or null if not bound.
	 * @param COMP2 the fixed value of pattern parameter COMP2, or null if not bound.
	 * @param PORT2 the fixed value of pattern parameter PORT2, or null if not bound.
	 * @param BIND2 the fixed value of pattern parameter BIND2, or null if not bound.
	 * @return a match represented as an array containing the values of each parameter, or null if no match is found.
	 */
	public Object[] getOneMatchAsArray(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		return getOneMatchAsArray(new Object[] {N1, COMP1, PORT1, BIND1, CHAN, N2, COMP2, PORT2, BIND2});
	}
	
	/** 
	 * Returns an arbitrary pattern match given some fixed parameters.
	 * Neither determinism nor randomness of selection is guaranteed.
	 * @param N1 the fixed value of pattern parameter N1, or null if not bound.
	 * @param COMP1 the fixed value of pattern parameter COMP1, or null if not bound.
	 * @param PORT1 the fixed value of pattern parameter PORT1, or null if not bound.
	 * @param BIND1 the fixed value of pattern parameter BIND1, or null if not bound.
	 * @param CHAN the fixed value of pattern parameter CHAN, or null if not bound.
	 * @param N2 the fixed value of pattern parameter N2, or null if not bound.
	 * @param COMP2 the fixed value of pattern parameter COMP2, or null if not bound.
	 * @param PORT2 the fixed value of pattern parameter PORT2, or null if not bound.
	 * @param BIND2 the fixed value of pattern parameter BIND2, or null if not bound.
	 * @return a match represented as a EnforcedRuleSignature object, or null if no match is found.
	 */
	public EnforcedRuleSignature getOneMatchAsSignature(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		return getOneMatchAsSignature(new Object[] {N1, COMP1, PORT1, BIND1, CHAN, N2, COMP2, PORT2, BIND2});
	}
	
	/**
	 * Indicates whether the given combination of specified pattern parameters constitute a valid pattern match,
	 * 	under any possible substitution of the unspecified parameters.
	 * @param N1 the fixed value of pattern parameter N1, or null if not bound.
	 * @param COMP1 the fixed value of pattern parameter COMP1, or null if not bound.
	 * @param PORT1 the fixed value of pattern parameter PORT1, or null if not bound.
	 * @param BIND1 the fixed value of pattern parameter BIND1, or null if not bound.
	 * @param CHAN the fixed value of pattern parameter CHAN, or null if not bound.
	 * @param N2 the fixed value of pattern parameter N2, or null if not bound.
	 * @param COMP2 the fixed value of pattern parameter COMP2, or null if not bound.
	 * @param PORT2 the fixed value of pattern parameter PORT2, or null if not bound.
	 * @param BIND2 the fixed value of pattern parameter BIND2, or null if not bound.
	 * @return true if the input is a valid (partial) match of the pattern.
	 */
	public boolean hasMatch(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		return hasMatch(new Object[] {N1, COMP1, PORT1, BIND1, CHAN, N2, COMP2, PORT2, BIND2});
	}
	
	/** 
	 * Returns the number of all pattern matches given some fixed parameters.
	 * @param N1 the fixed value of pattern parameter N1, or null if not bound.
	 * @param COMP1 the fixed value of pattern parameter COMP1, or null if not bound.
	 * @param PORT1 the fixed value of pattern parameter PORT1, or null if not bound.
	 * @param BIND1 the fixed value of pattern parameter BIND1, or null if not bound.
	 * @param CHAN the fixed value of pattern parameter CHAN, or null if not bound.
	 * @param N2 the fixed value of pattern parameter N2, or null if not bound.
	 * @param COMP2 the fixed value of pattern parameter COMP2, or null if not bound.
	 * @param PORT2 the fixed value of pattern parameter PORT2, or null if not bound.
	 * @param BIND2 the fixed value of pattern parameter BIND2, or null if not bound.
	 * @return the number of pattern matches found.
	 */	
	public int countMatches(Object N1, Object COMP1, Object PORT1, Object BIND1, Object CHAN, Object N2, Object COMP2, Object PORT2, Object BIND2) {
		return countMatches(new Object[] {N1, COMP1, PORT1, BIND1, CHAN, N2, COMP2, PORT2, BIND2});
	}
	


	/* (non-Javadoc)
	 * @see org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryMatcher#getPatternName()
	 */
	@Override
	public String getPatternName() {
		return "kevoree.enforcedRule";
	}

	private static final String[] paramNames = new String[] {"N1", "COMP1", "PORT1", "BIND1", "CHAN", "N2", "COMP2", "PORT2", "BIND2"};
	/* (non-Javadoc)
	 * @see org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryMatcher#getParameterNames()
	 */
	@Override
	public String[] getParameterNames() {
		return paramNames;
	}

	/* (non-Javadoc)
	 * @see org.eclipse.viatra2.emf.incquery.runtime.api.impl.BaseGeneratedMatcher#tupleToSignature(org.eclipse.viatra2.gtasm.patternmatcher.incremental.rete.tuple.Tuple)
	 */
	@Override
	protected EnforcedRuleSignature tupleToSignature(Tuple t) {
		return new EnforcedRuleSignature(t.get(0), t.get(1), t.get(2), t.get(3), t.get(4), t.get(5), t.get(6), t.get(7), t.get(8));
	}
	
	/* (non-Javadoc)
	 * @see org.eclipse.viatra2.emf.incquery.runtime.api.IncQueryMatcher#arrayToSignature(java.lang.Object[])
	 */
	@Override
	public EnforcedRuleSignature arrayToSignature(Object[] signature) {
		return new EnforcedRuleSignature(signature[0], signature[1], signature[2], signature[3], signature[4], signature[5], signature[6], signature[7], signature[8]);
	}	
	
	private EnforcedRuleMatcher(ReteEngine<String> engine) throws IncQueryRuntimeException {
		super(engine, "kevoree.enforcedRule");
	}
		
}
